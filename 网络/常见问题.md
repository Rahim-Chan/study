# HTTP1.1（文本格式传输）

1. 对头阻塞问题，没有解决（保持连接）
   HTTP管道化要求服务器端必须按照发送的顺序返回响应；那么如果一个相应返回延迟了，那么后续响应都会被延迟；
2. 慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的（带宽利用率）。
3. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
4. 文本传输效率问题，而且不安全
5. header中每次都传输类似头，增加了传输成本
6. 不够安全

http/1.1中的一个tcp链接**同时**只能发起一个http请求！浏览器会让每个域名同时最多建立6个tcp链接，也就是说同一个域名同时能支持6个http请求！

# HTTP2（流）

- stream
- message http的消息，响应，请求，由一个或多个帧组成；
- frame【http2最小单位】 每个帧包含帧首部【每个帧都分配一个序号】，至少会标识出当前帧所属的流（流标识），承载特定类型的数据；HTTP头部，payload；可以乱序发送，根据帧首部的流标识可以重装；
- 一个域名只维护一个TCP持久连接（减少带宽占用）；
- 可以设置请求的优先级
- 头部压缩

文档： [Google-Dev](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn)

# HTTP3

- upd+quic
- 实现了类似 TCP 的流量控制、传输可靠性的功能。
- 集成了 TLS 加密功能。
- 实现了 HTTP/2 中的多路复用功能。
- 实现了快速握手功能


# TLS 三次握手

- `client hello`带上TLS版本、密码组合、client random
- `server hello`发送证书、server random；选择密码组合
- 使用RSA算法生成`premaster secret`+公钥 加密
- 服务端使用私钥揭秘得出`premaster secret`
- 服务端跟客户的同时使用`client random` `server random` `premaster secret` 生成共享密钥
- **客户端就绪：** 客户端发送经过共享密钥 **KEY**加密过的"finished"信号。
- **服务器就绪：** 服务器发送经过共享密钥 **KEY**加密过的"finished"信号。
- **达成安全通信：** 握手完成，双方使用对称加密进行安全通信。

# TCP 与UDP区别

**只有通过IP地址、传输层协议和端口号三者才能在网络上定位到具体的服务；**

## TCP可靠性

### 检验和

目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到检验和有差错，则TCP段会被直接丢弃。

```
 以4bit 为例
        发送端计算：
        数据：   1000  0100   校验和  0000
        则反码：0111  1011               1111
        叠加：   0111+1011+1111 = 0010 0001   高于4bit的， 叠加到低4位      0001 + 0010 = 0011 即为校验和
 
        接收端计算：
        数据：  1000   0100   检验和  0011
        反码：  0111   1011                1100
        叠加：  0111 + 1011 +1100 = 0001 1110  叠加为4bit为1111.   全为1，则正确
```



### 面向连接（三次握手+四次挥手）确保可靠性

### 序列号和确认应答号（确保数据不会重复发送和重复接收）

1. 通过序列号和确认应答号，TCP能够识别是否已经接收数据，又能够判断是否需要接受；实现**重发控制**、**重复控制**。
2. 确认应答号（根据TCP首部中的序列号和数据长度）：接收端下一步应该接收的序列号；

### 超时重传

1. 超时时间确认：RRT（Round Trip Time）+ 波动时间 + 偏移量（偏大）；可以减少网络流量的浪费；
2. 重发超时都是0.5的整数倍，重发超时的默认值一般设置为6s左右；
3. 数据重发之后还是收不到确认应答，则进行再次发送。此时确认应答的时间将会以2倍、4倍的指数函数延长；
4. 达到一定次数，会判断为异常，强制关闭连接；

### 快速重传

1. 发送方在连续收到3个**重复的确认**后就开始执行重发，而不需要等待超时重发。不过这需要～～
2. 接收方每收到一个**失序**的报文就立即发送重复确认，而不是等待自己发送数据的时候进行捎带确认！！

### 滑动窗口-大量的缓冲区（**增加吞吐量**）

1. **大小**：是指无需等待确认应答ACK而继续发送数据的最大值；

特点：

- **窗口内的数据**即便是没有收到**确认应答**也可以被发送出去，不过在**整个窗口确认应答没到达之前**，发送端主机需要**设置缓存保留这些待被重传的数据**，直到收到他们的确认应答。
- 窗口外的部分包括**未发送**的数据以及**已经确认应答数据**

重发：

- 当ACK信号没有收到，可以通过下一个ACK进去确认；
- 快熟重发（接收到三次重复的ACK）；

### 流量控制 

1. 接收端通过ACK报文时，将自己的rwnd（receiver window）填入。而发送端根据窗口的大小改变发送速度
2. 当ACK为返回窗口大小为0是，发送端停止发送（！！当`接收端`处理完缓冲区后发送一个`窗口更新`的数据包通知）；
3. **持续计时器**： 当TCP连接的一方收到`0窗口通知`,就会启动他；定时发送一个`零窗口控测数据段`；

### 拥塞控制

- 慢启动算法
  初始化cwnd(Congestion Window) = 1；每经过一个传输轮次，cwnd都加倍1，2，4，8指数增长；
  `当cwnd >= ssthresh时，机会进入“拥塞避免算法”`
  
- 拥塞避免算法
  
  1. 当收到一个ACK时，```cwnd = cwnd+1/cwnd```
  2. 每经过一个RTT时，```cwnd=cwnd+1```
  
  ～～ 当拥塞发生，等到超出重发：```sshthresh=cwn/2;cwnd=1；``` 进入满启动。



## 端口号

端口号是主机和进程的中间层，进程和端口号即可以是一对一、一对多；端口号的引入可以让同时让主机上的多个进程对外提供服务，可以让一个进程对外提供多个服务；有了端口号，想要访问主机服务的请求也不需要通过进程进程标识符等方法定位服务的具体进程；

## 消息保护边界

传输协议把数据当作一条独立的消息在网络上传输，接收端只能接受独立的消息，也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；

而`面向流`则是无消息保护边界，如果发送端连续发送数据，接收端一次接收动作中，会接收到两个或者更多的数据包；

**结论：**

 TCP为了数据的可靠传输，尽量减少额外开销（每次发包都要验证），因此采用了流式传输，面向流的传输，这样可以减少发送包的数量。对于接收端来讲，如果机器负载很重，使用TCP可能会容易`粘包`；因此需要额外拆包，增加了工作量，因此适合数据可靠性高，频率低的场合（两次操作100ms，具体由内核中的socket决定）；

而UDP发送的频率较高时，会增加系统（发送端、接收端）的开销；因此最好设置一个比较合适的数据包的包长（UDP最大载荷为1472，因此最好能够每次接近这个数据量，适合于视频，音频等大块数据的发送，同时减少握手来保证流媒体的实时性）；

TCP无保护消息边界的解决：（解决粘包）

- 发送固定长度的消息 （适合消息长度不是很长的情况）【！HTTP协议的消息边界就是基于content-length实现】
- 把消息的尺寸与消息一起发送
- 使用特殊标记来区分消息间隔【如果HTTP使用块传输，就会使用负载大小为0的HTTP消息作为终结符表示消息边界，当然使用TCP协议发送JSON消息，接收方可以通过是否解析成合法的JSON去判断消息是否终结】

## 丢包【wip】

### TCP

TCP协议本身确保传输的数据不会丢失的完整性。如果在传输过程中发现数据或者数据包丢失，最大的可能性就是在发送或者接收程序的过程中出想问题；

Send函数频率很高（1. 程序处理逻辑错误，2.多线程同步问题，3.缓冲区溢出），如果没有对send发送失败作处理，客户端收到的数据比理论收到的要少，就会造成丢数据，丢包现象。

- Linux内核socket缓冲区太小
- 服务器负载太高，占用大量cpu资源
- 磁盘IO忙【磁盘满】

## 协议头

- UDP 协议头中只包含4个字段：源端口、目标端口、长度和校验码；一个字段16个bit(2个字节)，所以一共8个字节（8bit = 1byte）「只包含了两个端口号的 UDP 协议本身是无法提供路由和寻址功能的」
- TCP协议头中游20个字节信息

|              | TCP                          | UDP                            |
| :----------- | ---------------------------- | ------------------------------ |
| 是否连接     | 面向连接                     | 无连接                         |
| 是否可靠     | 可靠，使用流量控制和拥塞控制 | 不可靠                         |
| 连接对象个数 | 一对一                       | 一对一、一对多、对多一、多对多 |
| 传输方式     | 面向字节                     | 面向报文                       |
| 首部开销     | 最小20字节，最大60字节       | 仅8个字节                      |
| 适用场景     | 文件传输                     | IP电话、视屏会议、直播         |



# 头部信息

## vary

 代理服务器需要带这个字段，否则可能存在缓存错乱，vary: accept-encoding;



# DNS

## [TTL (Time-To-Live)](https://www.cloudflare.com/learning/cdn/glossary/time-to-live-ttl/) 

**What:** TTL is a numerical value that determines how long a DNS cache server can serve a DNS record befored reaching out  to the  authoritative DNS server and geting a new copy of record;

## DNS record

**What:** DNS records are instructions that live in authoritative DNS and provide infomation about a domain including what IP address is associated with that domain and how to handler request for domain. These records consist of series of text files wirtten in what is knows as DNS syntax;

**HOW:** DNS syntax is just a characters used as commands that tell DNS server what to do. All DNS records also have  "TTL".

- **A record:** ip address
- **CNAME：** Forworad a domain or subdomain to anthoer domain;

# CDN





