# mode

value: `development` 、 `production` 、`none`

# entry

`string`、`array`、object、

- array 多主入口文件（mutil-main-entry）
  应用场景，打包cjs、esm、umd
- object 多个入口文件
  多页面打包

# output



# Tree Shaking

必须遵循ES6的模块规范（import & export）,如果是的CommandJS规范（require）则无法使用；

如果是在webpack2中，需要开启`.babelrc`配置；表示不对es6模块进行处理；

```json
// .babelrc
{
  "presets": [["es2015", { "modules": false }]]
}
```

ES6的模块依赖关系是确定的，和运行时状态无关，可以进行`静态分析`;

## 实现细节

- 所有`import`标记为`/* harmony import*/`
- 被使用过的`export`标记为`/* harmony export ([type])*/`，其中[type]和webpack内部有关，可能是`binding`、`immutable`
- 未被使用过的`export`标记为` /* unused harmony exprot [FuncName] */`,其中[FuncName]为export的方法名称
- 之后在uglifyjs（或者其他工具）步骤进行代码精简；

## import()编译后

参考：https://juejin.im/post/6850418111599165448；

### webpack.require.e

编译后import被编译成webpack自定义的webpack.require.e函数：

- 定义一个promise数组；
- 判断是不是加载过，是的话返回一个空数组的promise.all()
- 如果是正在加载中，则返回存储文件对应的**promsie**；
- 如果没有加载过，先定一个promise，然后通过**jsonpScriptSrc**记载js，并定义成功和失败的回调；

### x.bundle.js

- x.bundle.js是Import()分割的文件代码；
- 异步加载代码后，代码执行webpack['webpackJsonp'].push的方法，执行promise的resolve方法；
- 执行加载成功回调

## SourceMap

参考：https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/sourcemap#cheap-module-source-map

不外敷： 安全性、效率、信息开放度、体积配置推荐

开发环境推荐：

cheap-module-eval-source-map

生产环境推荐：

cheap-module-source-map （这也是下版本 webpack 使用 `-d` 命令启动 debug 模式时的默认选项）

原因如下：

1. **使用 cheap 模式可以大幅提高 souremap 生成的效率。**大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息。
2. **使用 eval 方式可大幅提高持续构建效率。**参考官方文档提供的速度对比表格可以看到 eval 模式的编译速度很快。
3. **使用 module 可支持 babel 这种预编译工具**（在 webpack 里做为 loader 使用）。
4. **使用 eval-source-map 模式可以减少网络请求。**这种模式开启 DataUrl 本身包含完整 sourcemap 信息，并不需要像 sourceURL 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率。而生产环境中则不宜用 eval，这样会让文件变得极大。





https://louiszhai.github.io/2019/01/04/webpack4/
https://zhuanlan.zhihu.com/p/110995118