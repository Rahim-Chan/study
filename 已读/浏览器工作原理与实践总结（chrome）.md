# 浏览器工作原理与实践总结（chrome）

为什么以chrome浏览器为分析的对象，因为国内市面上大多浏览器在chromium基础上二次开发，只有业务层面的区别。

## 从浏览器宏观视角下讲诉（从URL到页面展示中间发生了什么？）

- 进程

最新的chrome浏览器包括：（多进程浏览器来了稳定性、安全性、流畅性，避免不了更多资源占用、复杂的体系架构）

1. 浏览器主进程、GPU进程、网络进程都只有1个
2. 多个渲染进程、插件进程

- 从URL到页面展示中间发生了什么？

### 导航流程

#### 用户输入URL

1. 浏览器会判断用户输入的内容是否符合URL规则，是的话则加上**协议**，否则用浏览器默认搜索引擎合成新的带关键字的URL。

2. 用户按下回车键之后，浏览器会判断用户有没有监听beforeunload事件，因此用户可以通过改事件来取消导航。

3. 当用户确定之后你会发现，浏览器标签上出现加载中的图标，但是页面还是保持不变。因为需要等待

   <u>提交文档</u>阶段，页面内容才会被替换。

#### URL请求过程

接下来**浏览器进程**会把URL的内容发送到**网络进程**！

##### 浏览器发起Http请求

1. 构建请求
   浏览器构建**请求行**信息，准备发起请求。

   ```http
   GET /index.html HTTP1.1
   ```

2. 查找缓存
   在真正发起请求之前，浏览器先在浏览器缓存中是否存在副本，会拦截请求不会去源服务器下载。（一笔带过）

3. 准备IP和端口
   解析DNS（Domain Name System，**域名系统**）返回域名对呀的IP，通常情况下，如果URL没有指定，默认是80端口（https是443）。

4. 等待Tcp队列
   chrome下同一个域名最多只能建立6个Tcp连接。

5. 建立Tcp队列（如果是**https:** 还需要建立 TLS 连接）

6. 发送Http请求

   - 首先浏览器会先服务器发送请求行（请求方法、请求URI，http版本）

     1. 服务端返回请求
        返回请求行，包括版本协议和状态码。

     2. 断开连接

        浏览器或者服务器在其头信息中加入了

        ```
        Connection:Keep-Alive 
        ```

        TCP在发送后仍然保持连接，可以省去下次请求时需要建立连接的时间。

##### 处理响应体

1. 重定向（根据这响应头的location字段）
   浏览器中打开baidu.com后，最终浏览器打开的地址是www.baidu.com。这个需要服务器做处理。
   比如说：https://12306.cn，是打不开的。
2. 处理响应体数据类型
   Content-Type是头中一个非常重要的字段：
   如果是text/html，浏览器则会继续进行导航流程，如果是application/octet-stream，浏览器则会下载文件导航流程就此结束。

#### 准备渲染进程

浏览器接受到`网络进程`的响应头数据后，便准备渲染进程。(todo：浏览器的谁接收到，让谁去准备)

Chrome 会为每个页面分配一个渲染进程，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

- 同站点

  ```
  https://time.geekbang.org
  https://www.geekbang.org
  https://www.geekbang.org:8080
  ```

总结来说，打开一个新页面采用的渲染进程策略就是：通常情况下，打开新的页面都会使用单独的渲染进程；

- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；

- 如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

这时候还不能进入文档解析状态，因为文档还在网络进程中，并没有交给渲染进程！！（IO比网络快吧）

#### 提交文档

- `渲染进程`接收到`浏览器进程`的“提交文档”后，会和`网络进程`建立传输数据的“管道”；

- 等文档传输完成之后，渲染进程->浏览器进程发送“确认提交”；
- 浏览器进程会更新页面，包括安全状态，地址了URL，前进后退的历史状态。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。



### 渲染流程

#### 构建Dom树

因为浏览器无法直接理解和使用HTML，所以需要将HTML转化为浏览器能够理解的结构—DOM树

#### 样式计算 （Recaluate Style）

1. css文本转化成可以理解的结构

   和浏览器一样CSS样式无法被直接是使用，当渲染器接收到CSS文本时，会把它转换成可以理解的结构—styleSheets。

2. 转化样式表中的属性值，使其标准化
   ps：em->px ; red-> rgb(xxx,xxx,xx);

3. 计算DOM树中每个节点的具体样式

   - 样式的继承
   - 层叠的计算

#### 布局阶段

计算出DOM树中可见元素的几何位置，把这个过程叫布局

1. 构建布局树
   - 遍历DOM树中所有可见节点，并把这些节点加到布局中；
   - 遇到不可见的节点会被布局树忽律，eg：heade标签下面的全部内容、或者属性包含display:none的元素
2. 布局计算

#### 分层

类似ps的图层，把画面分成几层。渲染引擎为特定的节点生产专用的图层，并生成一颗对应的图层树（LayerTree）。
如果一个节点拥有以下特点，将<u>单独</u>一层，否则就从属<u>父节点</u>的图层。

1. 拥有层叠上下文属性的元素。
2. 需要裁剪的地方也会被创建为图层。

#### 图层绘制

图层绘制的结果就是输出：绘制指令、绘制顺序。

#### 栅格化（raster）

当图层的绘制列表准备好之后，主线程会把该绘制列表<u>提交</u>（commint）给<u>合成线程</u>。

1. 图块（tile）
   合成线程会图层划分为图块，大小通常为256*256、512**512。

2. 合成位图

   - 合成线程会就视口（viewpoint）附近的图块来优先生成<u>位图</u>。实际合成位图是由栅格化来执行的。

   - 渲染进程里面维护了一个栅格化线程池，所有的图块栅格化都在里面进行。
   - 通常栅格化都会使用GPU来加速生成，这个过程叫做“快速栅格化”、“GPU栅格化”，生成的位图会被保存在GPU内存中。

3. 合成和显示

   - 一旦所有的图块都被栅格化，合成线程就会生成一个绘制图块的命令“DrawQuad”，然后提交给浏览器进程。
   - 浏览器进程里面有个叫Viz的组件，用来接受”DrawQuad“命令，然后根据命令，将其页面内容绘制到内存中，最后将内存显示到屏幕中。（具体呢）

   1. 重排（reflow）
      如果通过css或者js来改变元素的<u>几何</u>属性，会重新执行：
      主线程：样式计算->构建布局->分层->绘制
      非主席： 分块->栅格化->draw quad-> display

   2. 重绘（repaint）

      如果通过css或者js来改变元素的<u>非几何</u>属性，比如背景颜色，会重新执行：
      主线程：样式计算->绘制
      非主席： 分块->栅格化->draw quad-> display

   3. 合成
      我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。

## 浏览器中js执行机制

### 变量提升

之所以需要变量提升，因为JavaScript需要先<u>**编译**</u>，在<u>**执行**</u>。

1. 编译阶段
   变量和函数会被存到**<u>变量环境</u>**中，变量的默认值会被设置为undefind; JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置。
2. 执行阶段
   js引擎会去环境变量中查找自定义的变量和函数。

### 调用栈

#### 执行上下文

包括：变量环境、词法环境

1. 当js执行全局代码的时候，会编译代码并创建全局**<u>执行上下文</u>**。
2. 当调用一个函数的时候，函数内部的代码会编译，并创建函数**<u>执行上下文</u>**，当函数结束后，该上下文会被摧毁。
3. 当使用eval函数的时候同上操作。

又称执行上下文栈，把一个个的执行上下文压入栈的顶部；
栈溢出：调用栈是有大小的，当栈的执行上下文超出了一定的数目就会报错。



### 作用域（scope）和块级作用域

定义了函数和变量的可访问范围，即作用域控制着函数和变量的<u>可见性和生命周期</u>。

在es6之前，es的只有以下两种作用域。

- 全局作用域
- 函数作用域
- 块级作用域
  其实，在上下文中的词法环境内部维护着一个小型栈结构，通过它let，const关键字创建的变量会被存放到这里面。栈低是函数最外层的变量。当进入一个作用域后，就会把该作用域内部的变变量压倒栈顶；

因此，js引擎会沿着词法环境从栈顶向下查询，如果词法环境里面查询不到，继续在变量环境中查找，否则返回变量值。

### 作用域链

```javascript
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "foo"
    bar()
}
var myName = "win"
foo()
```

答案：“win”。

每个执行上下的变量环境中，都包含了一个外部引用，用来指定外部的执行上下文，我们把这个外部引用称为**<u>outer</u>**。

如果一个变量在当前执行上下文查找不到，就会通过outer所指向的执行上下文去查找，我们把这个查找的链条叫做“**<u>作用域链</u>**”。那么outer的指向是通过接下来“词法作用域”来确定的！

#### 词法作用域

词法作用域是值“作用域”是有代码中“函数声明”的位置来决定的，所用词法作用域是**<u>静态作用域</u>**。这也就解释了`bar`中`myName`的值怎么不是`foo`函数中的“foo”，而是全局上下文中的“win”。

### 闭包

内部函数引用了外部函数的变量依然保存在内存中，这些变量的集合称为闭包。

```javascript

function foo() {
    var myName = "foo"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("win")
bar.getName()
console.log(bar.getName())
```

除了get、set函数能访问到的地方，称之为foo函数的闭包。
最下面的 Global 就是指全局作用域，从“Local–>Closure(foo)–>Global”就是一个完整的作用域链。

### THIS的指向

按照顺序判断`this`的绑定对象：

1. 有 `new`调用：绑定到新创建的对象
2. 由`call`或`apply`、`bind`调用：绑定到指定的对象
3. 有上下文对象调用：绑定到上下文对象
4. 默认全局对象

​	MDN上这样写：

> In most cases, the value of this determined by how a function is called.
>
> 在绝大多数情况下，怎么调用函数的值决定了this的值。

**结论： this的指向，是在调用该函数时根据执行上下文所动态确定的！**

##### call、apply的第一个参数

- `call`，`apply`作用之一就是用来修改函数中的`this`指向为第一个参数的。 第一个参数是`undefined`或者`null`，非严格模式下，是指向`window`。在严格模式下指向的是`undefined`。
- 如果输入的第一个参数是原始值，在非严格模式下，那么this将指向原始值的自动包装对象；在严格模式下是指向原始值；

[apply的实现](../实现/apply-demo.html)

[call的实现](../实现/call-demo.html)



## 浏览器中页面循环系统

### 事件循环

线程在执行完实现安排好的任务后就会推出线程，然而不是所有的任务都是实现安排好的，线程在运行的过程中，能接受新的任务，就学要采用事件循环来监听。

### 消息队列

消息队列中的任务是通过事件循环系统来执行的

[WHATWG 规范]: https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-mode

中定义了事件循环的标准；

- 一种数据结构(FIFO)，存放要执行的任务。
- 其他线程可以往消息队列添加任务，由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个**<u>同步锁</u>**？？

- **<u>渲染进程</u>**中，有一个IO线程专门用来接受其他**<u>进程</u>**传进来的消息，然后添加到消息队列的尾部。
- 渲染主进程会循环从消息队列头部读取、执行任务。

页面主线程会设置一个标志，每次执行完一个任务，就回去判断是有推出标志。如果有直接退出线程。

### 延迟队列

为了实现定时器setTimeout功能，浏览器新增了延迟队列。

执行时机：消息队列中的一个任务完成后。

1. 当前任务执行太久，会影响 到**<u>期定</u>**时器任务的执行；

2. setTimeout如果存在嵌套，会延长执行时间。chromium实现：定时器嵌套调用5层以上，最小调用间隔设置为4ms；

3. 未激活页面，setTimeout最小间隔1000ms；

4. 延迟时间最大值，32bit最大能存储的数字2147483647 毫秒（24.8天），当大于这个值时，将被设置为0；

5. setTimeout设置的回调函数中this被设置为window，严格模式下undefined;

   

### 系统调用栈

只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，xhr就是通过调用栈异步回调，网络进程通过IPC把任务添加到消息队列。

### 宏任务

- 渲染事件（解析DOM、计算布局、绘制）；
- 用户交互事件；
- javascript脚步执行事件；？？
- 网络请求完成、文件读取完成事件；
- setTimeout

### 微任务

- MutationObserver
- Prmoise

###  协程

- 协程是一种比线程更轻量级的存在，不被操作系统内核控制，完全由程序控制，不会像切换进程那样消耗性能；

- 一个线程可以拥有多个协程；

  ```javascript
  
  function* genDemo() {
      console.log("开始执行第一段")
      yield 'generator 1'
  
      console.log("开始执行第二段")
      yield 'generator 2'
  
      console.log("开始执行第三段")
      yield 'generator 3'
  
      console.log("执行结束")
      return 'generator 4'
  }
  
  console.log('main 0')
  let gen = genDemo()
  console.log(gen.next().value)
  console.log('main 1')
  console.log(gen.next().value)
  console.log('main 2')
  console.log(gen.next().value)
  console.log('main 3')
  console.log(gen.next().value)
  console.log('main 4')
  ```

  1. 通过调用生成器genDemo来创建一个协程gen，gen协程并没有立即执行；
  2. 通过.next可调用内部执行协程；
  3. 通过yield关键字可以暂停gen协程的执行，并返回主要信息，把控制权交给主线程；
  4. 

## 浏览器中的页面

### JavaScript如何影响DOM树的构建

#### 什么是DOM

从网络传给渲染渲染引擎的HTML字节流是无法直接被渲染引擎理解的，要专程渲染引擎能够理解的内部结构（DOM）。

#### 如何生成DOM

- 渲染引擎内部，又一个HTML解析器（HTMLParser）的模块，将HTML字节流转成DOM结构。
- 网络进程会与渲染进程之间建立一个数据共享的管道，解析器会一边接受一边解析。

#### 怎么解析DOM

1. 通过分词器将字节流转换成Token；
2. 将Token转成DOM节点，并插入到DOM树中；

#### JavaScript如何影响DOM的生成

- 解析器遇到解析道script标签，此时JavaScript引擎会介入，并暂停解析，知道脚步执行完毕；
- 遇到JavaScript文件，需要先下载代码文件，受网络环境、文件大小影响，会阻塞DOM解析；如果文件中没有操作DOM相关代码，就可以将脚步设置为异步加载，`async`和`defer`来标记；
- 如果脚步中，有操作CSSOM的语句，引擎会选解析语句之上所有的CSS样式；如果引用了外部的CSS文件，那么在执行脚步之前，要需要等待外部CSS文件下载完成，解析生成CSSOM之后，才能执行脚步；



## 浏览器安全

### 同源策略

相同的URL协议，端口，域名。

#### 限制

1. DOM层面

   ```javascript
   let pdom = opener.documentpdom.body.style.display = "none"
   ```

   

2. 数据层面:cookie:,IndexDB,LocalStorage

3. 网络请求

#### 方便

1.  页面中嵌入第三方资源

2. 跨域资源共享和跨文档消息机制（window.postMessage）

   

### 跨站脚步攻击（XSS）

（Cross site scripting）为了重命名故简称“XSS”。

#### 类型

- 存储型
  利用站点漏洞，将一段恶意代码js代码存储到网站的数据库中；

- 反射性

  ```xml
  http://localhost:3000/?xss=<script>foo</script>
  ```

  服务器接收到恶意代码的请求，又被恶意代码反射给浏览器。

- DOM
  协议网络在页面传输的过程中修改HTML。

#### 防范

- 脚步进行转码
- 充分利用CSP
  - 限制下载其他域名的脚步；
  - 禁止向第三方提交数据；
  - 禁止执行行内脚步和未授权的脚步；
  - 提供上报机制，发现xss攻击；
- 利用HttpOnly属性（无法脚步读取，修改）

### CSRF攻击（Cross-site request forgery）

又名“**跨站请求伪造**”，打开黑客的网站，利用用户的登录状态发起请求。发生在第三方。

#### 攻击对象

- 目标站点有CSRF漏洞；
- 用户登录过目标站点，并且保持登录状态；

#### 防范

- 设置cookie的SameSite模式（Strict，Lax，None）
- **同源校验**-验证请求的来源站点（Referer，Origin）

- CSRF Token，浏览器索取token（第三方站点无法获取），请求的时候带上。

## 浏览器中的网络 (未编辑)

### HTTP

#### 一、基本概念

HTTP，Hyper Text Transfer Protocol（超文本传输协议），是**浏览器和服务器之间的通信传输协议**，基于TCP/IP协议来传输数据。

##### 特点

1. 无状态。每次HTTP请求都是独立的，不会保留状态信息。
2. 灵活。HTTP允许传输任意类型的数据。
3. 无连接。早期HTTP每进行一次HTTP，都要断开一次TCP连接。（1.1开始优化此特点）

##### HTTP报文

1. **请求报文**

   **请求行** 是由 **请求方法 + 请求路径 + 协议版本**，如下

   ```javascript
   GET /index HTTP/1.1
   ```

   **请求头**是由键值对组成，描述请求的相关信息，如下

   ```javascript
   host: www.taobao.com
   accept: text/html
   accept-encoding: gzip, deflate, br
   accept-language: zh-CN,zh;q=0.9
   cache-control: no-cache
   ```

   **请求体**就是需要发到服务端的数据，也就是`body`部分。
   **注意：在请求头和请求行之间必须要有一行空行，用来区别请求头和请求体，如下所示**

   ```javascript
   GET /index HTTP/1.1
   ...
   cache-control: no-cache
   				👈这里必须有一行空行
   body
   ```

2. **响应报文**

   **响应行**是由 **HTTP版本 + 状态码 + 原因**，如下

   ```javascript
   HTTP/1.1 200 OK
   ```

   **响应头**也是由键值对组成，与请求头结构一样。
   **响应体**就是接收到的数据

##### HTTP状态码

状态码为3位数，分为五类：

* **1xx**：表示临时响应，需要后续操作
* **2xx**：表示成功
* **3xx**：表示重定向
* **4xx**：表示客户端请求错误
* **5xx**：表示服务器发生错误

##### HTTP请求方法

* **GET**：通常用来获取资源
* **POST**：提交数据
* **HEAD**：获取资源的元信息，响应体不会被返回
* **PUT**：修改数据
* **OPTIONS**：预检请求，通常在跨域请求时出现
* **DELETE**：删除资源（基本不用）
* **TRACE**：追踪请求，回显服务器收到的请求，主要用于测试
* **CONNECT**：预留给能够将连接改为管道方式的代理服务器

##### 三次握手与四次挥手

参考：[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

1. **三次握手**

   建立一个连接需要三次握手，初始状态，客户端为Closed，服务端为Listen。
   第一次握手：客户端发送一个SYN报文，同时指明客户端序列号，此时状态为**SYN_SEND**。
   第二次握手：服务端收到SYN报文后，以自己的SYN报文、客户端的序列号 + 1作为ACK值和服务器序列号作为应答，此时状态为**SYN_REVD**。
   第三次握手：客户端收到SYN报文后，将服务器序列号 + 1作为ACK值，发送ACK报文给服务器，此时客户端状态为**ESTABLISHED**，服务端接收到报文也处于**ESTABLISHED**

2. **四次挥手**
   终止一个连接需要经过四次挥手，一开始客户端和服务端都处于ESTABLISHED状态。
   客户端或服务端都可以主动发起挥手请求。以客户端为例。
   第一次挥手：客户端发送FIN报文 ，报文中指定一个序列号，此时状态为**FIN_WAIT1**。
   第二次挥手：服务端接收到FIN报文后，会发送ACK报文，将序列号 + 1作为ACK的值，此时服务端状态为**CLOSE_WAIT**，客户端接收到服务端的确认后，进入**FIN_WAIT2**状态。
   第三次挥手：服务端确认要断开连接后，发送FIN报文，同时指定一个序列号，进入**LAST_ACK**状态。
   第四次挥手：客户端接收到FIN报文后，发送ACK报文做确认，进入**TIME_WAIT**状态，等待计时器设置的2MSL后，才会进入**CLOSED**。服务端在收到ACK报文后，就关闭连接了，进入**CLOSED**。

#### 二、HTTPS

HTTPS简单来说就是HTTP的安全版本。在HTTP的基础上加入SSL层进行传输数据加密。

##### 为什么需要HTTPS？

HTTP存在的问题：

* 通信使用明文，数据可能被窃听
* 无法证明报文的完整性，可能在传输中被篡改
* 不验证通信方的身份，可能遭遇伪装

HTTPS协议主要依赖TLS/SSL协议，该协议主要依赖三种算法：

* 非对称加密：又称公钥密钥加密，这里用于加密对称密钥，实现身份验证和密钥协商。
* 对称加密：又称私钥加密，即信息的发送方和接收方用一个密钥去加密和解密数据。这里用于加密传输数据。
* 散列算法：验证数据的完整性

![img](.\images\1634e5e77c014d22.jpg)

##### TSL/SSL四次握手过程

第一次握手：客户端发起一个HTTPS请求，携带**客户端生成的随机数**和**客户端支持的算法**。

第二次握手：服务端选择算法并返回**公钥证书**和**服务端生成的随机数**。

第三次握手：客户端验证证书有效性，生成**新的随机数**，同时根据3个随机数生成**对称密钥**，并用证书中的公钥加密**对称密钥**，发送给服务器。

第四次握手：服务端使用自己的私钥解密得到**对称密钥**，至此，客户端和服务端都用对称密钥。最后发送一段加密通知，表示握手结束，以后HTTPS请求都会经过对称密钥加密传输。

#### 三、HTTP / 0.9  - HTTP / 3

##### HTTP / 0.9

最早的 HTTP / 0.9，用来在网络之间传递 HTML 超文本的内容，所以被称为**超文本传输协议**。
当时需求简单，所以请求中只有一个**请求行**，没有**请求头和请求体**的概念。

##### HTTP / 1.0

随着需求增加，不止单纯加载HTML，还需要加载js，css，图片，音频等不同类型文件，HTTP / 1.0出现了。

为了告诉服务端更多的信息，HTTP/1.0 引入了**请求头和响应头**，比如需要什么类型的文件，压缩方法，编码方式等等。

除了引入请求头和响应头，还有几个重点功能：

* **状态码**：告知客户端，服务器的执行状态，方便客户端决定下一步操作。
* **Cache机制**：缓存下载过的数据。

请求流程图如下：

![img](.\images\HTTP1.0请求流程.png)

##### HTTP / 1.1

由于需求不断更新，1.1版本在1.0基础上面做了一些新的改进，这里列举比较重要的3个。

1. **持久连接**
   原因：1.0版本每进行一次HTTP通信，都需要经过TCP建立，传输，断开三个阶段，如果请求多的话，开销会过大。

   HTTP/1.1 中增加了**持久连接**的方法，特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。
   目前浏览器对同一域名，默认允许建立**6个TCP连接**。

2. **分块传输**（**Chunked transfer encoding**）
   原因：1.0需要在响应头中设置Content-Length字段表明数据大小，但是有些数据是动态生成的，在内容创建完之前是不可知的。
   分块传输将数据切割成若干份数据块，每个数据块传输时附上上个数据块的带下，最后使用一个0长度块结尾，提供了对动态内容的支持。
   服务器有时会进行压缩传输，分块传输可以一边压缩一边发送数据，压缩发送同时进行。

3. **Cookie**
   原因：HTTP是无状态协议，但是有些情况下需要保存一些状态，比如登陆状态。
   服务端通过响应头中的Set-Cookie字段，通知客户端保存该Cookie值，客户端会自动在每次请求头中加入Cookie字段。服务端根据Cookie值去获取相应的状态信息。

HTTP / 1.1的主要问题：

1. TCP慢启动。是为了减少网络拥塞的一种策略，但是有些重要资源的加载因为慢启动，导致耗费时间较长。
2. TCP连接竞争带宽。当带宽不足时，各个TCP会动态减慢接收数据的速度，影响关键资源的下载。
3. 队头阻塞。持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求。

**HTTP / 2**

HTTP/ 2 解决的就是HTTP / 1.1存在的主要问题。现在大部分资源请求较多的网站都采用了HTTP/ 2。
下图为HTTP / 2 协议栈。

<img src=".\images\HTTP2协议栈.png" alt="img" style="zoom: 25%;" />

1. **二进制分帧层**
   请求数据通过**二进制分帧层**后，会分割成带有ID编号的帧发送给服务端，服务端接收到所有帧后，根据相同的ID编号组成多个完整的请求。响应数据也是如此。

2. **多路复用**（核心机制）

   多路复用是基于二进制分帧层的基础上实现。
   同个域名只需要**一个TCP连接**，一个连接**并行**执行多个请求和响应，解决了HTTP / 1. 1的多个连接慢启动，同时也避免了多个TCP连接的带宽竞争。

3. **请求优先级**
   在发送请求时可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。服务端会根据优先值，优先处理高优先级的请求。

4. **Hearder压缩**
   客户端和服务端都会跟踪之前发送的头部信息，相同的头部信息只需发送一次，下次其他请求里面只发送有差异的键值对即可。

5. **Server Push**

   服务器可主动推送数据到客户端。比如用户请求一个HTML，服务器知道这个HTML需要的JS，CSS文件，那么接收到请求后，主动推送资源文件给到浏览器。

6. **安全性**
   HTTPS是大势所趋，主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以HTTP / 2 可以认为是加密的。

HTTP / 2 存在的主要问题：

* TCP队头阻塞没有彻底解决
* TCP建立连接延迟

##### HTTP / 3

由于TCP协议的缺陷，HTTP / 3新开发了基于UDP协议的**QUIC**协议。

<img src="./images/HTTP3协议栈.png" alt="img" style="zoom: 50%;" />

1. 实现了类似 TCP 的流量控制、传输可靠性的功能。
2. 集成了 TLS 加密功能。
3. 实现了 HTTP/2 中的多路复用功能。
4. 实现了快速握手功能。

#### 四、HTTP缓存

##### 强缓存

强缓存指的是不会发送请求，直接从缓存中读取资源。HTTP/1.0中，使用的是**Expires**

字段，HTTP/1.1使用的是**Cache-control**。

1. **Expires**
   缓存过期时间，指定资源到期的时间。如下：

   ```javascript
   Expires: Wed, 22 Nov 2019 08:41:00 GMT
   ```

   表示资源在2019年11月22号8点41分过期。
   expires有个问题，当客户端和服务端时间不一致时，这个缓存的时间就是不准确的。

2. **Cache-Control**
   HTTP / 1.1通过Cache-control定义缓存策略。
   通过`max-age`定义过期时长控制缓存，如下：

   ```javascript
   Cache-Control:max-age=3600
   ```

   表示资源在3600秒后资源才过期。

   常用指令：

   ![img](./images/Cache-Control.png)

3. **Expires** 和 **Cache-Control**的区别
   一个是1.0的产物，一个是1.1的产物，当两者同时存在时，Cache-Control优先级高于Expires；现阶段基本都是使用Cache-Control，Expires算是一种兼容写法了。
   当强缓存失效后，为了知道服务端的文件是否发生改变了，就需要用到**协商缓存策略**。

##### 协商缓存

强缓存失效后，浏览器在发送请求时，会在请求头带上`缓存标志tag`，服务端根据这个tag来判断是否使用缓存，这就是**协商缓存**。有两种机制**Last-Modified** 和 **ETag**。

1. **Last-Modified**
   第一次请求资源时，如果服务端在响应头加上这个字段，表示该资源在服务端最后的修改时间，浏览器会缓存该字段值。

   ```javascript
   Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
   ```

   浏览器下次请求这个资源时，检测到有Last-Modified，会在请求头添加一个**If-Modified-Since**字段，值为**Last-Modified**的值。
   服务端会根据**If-Modified-Since**的时间对比服务器上文件的最新修改时间

   * 如果没有变化，返回304状态码，浏览器直接从缓存取。
   * 如果有变化，则返回200状态码和最新的资源文件。

2. **ETag**
   **ETag**是服务端根据当前文件的内容，生成文件**唯一标识**，只要文件内容有变化，这个值就会变。
   浏览器接收到ETag的值后，会在下次请求该资源时，在请求头中添加**If-None-Match**字段，并赋值给该字段，发送给服务端。
   服务端会根据**If-None-Match**字段，对比服务端的ETag：

   * 如果没有变化，返回304，浏览器直接从缓存取。
   * 如果有变化，返回200码及最新资源。

3. **Last-Modified** 和 **ETag** 对比

   * 在精准度上，ETag优于Last-Modified。
   * 性能上，Last-Modified优于ETag。前者只记录时间，后者需要算法计算出一个hash值。
   * 优先级上，服务器校验优先考虑ETag。

##### 缓存位置 (后续补充)

参考：[https://github.com/ljianshu/Blog/issues/23](https://github.com/ljianshu/Blog/issues/23)

## 浏览器垃圾回收机制

### 回收机制

JavaScript采用的是**自动垃圾回收**的策略，产生的垃圾数据是由垃圾回收器来释放的。

### 栈数据回收

执行代码时，会有一个**ESP指针**，记录当前执行状态的指针（称为 ESP）。
 JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

```javascript
function foo(){ 
    var a = 1
    var b = {name:"name1"}
    function showName(){
        var c = "name2"
        var d = {name:"name2"}
    }
    showName()
}
foo()
```

![img](https://static001.geekbang.org/resource/image/b1/3b/b1f0573287b487016334c3f8ec23073b.png)

当showName()函数执行完之后，ESP指针下移到foo()函数，showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。当foo()函数再次调用其他函数时，这块无效内存会被直接覆盖掉，这就完成了栈回收。

所以说，**当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

### 堆数据回收

当执行上下文被无效后之后，堆中的数据依然占用着空间。**要回收堆中的数据，就需要JavaScript中的垃圾回收器**

#### 需要理解的概念：代际假说，分代收集

##### 代际假说

* 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问
* 不死的对象，会活得更久

##### 分代收集

*  **新生代** 新生代中存放的是生存时间短的对象
*  **老生代** 老生代中存放的生存时间久的对象

##### 垃圾回收器

* 副垃圾回收器，主要负责新生代的垃圾回收。
* 主垃圾回收器，主要负责老生代的垃圾回收。

#### 垃圾回收器工作流程

1. 第一步标记空间的**活动对象**和**非活动对象**。活动对象指还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 第二步回收非活动对象占据的内存。
3. 第三部做内存整理。频繁回收对象后会产生不连续的内存空间，称为**内存碎片**（副垃圾回收器不会有内存碎片）。

##### 副垃圾回收器

采用**Scavenge**算法，将新生代空间对半划分为**对象区域**和**空闲区域**。

<img src="https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png" alt="img" style="zoom:50%;" />

新对象放入对象区域，当对象区域快满时，执行清理操作，存活下来的对象放入空闲区域。然后将两个区域翻转，即原空闲区域变成对象区域，对象区域变成空闲区域。通过这种翻转操作让新生区无限使用下去。

注：JavaScript还采用了**对象晋升策略**，如果经过两次清理还存活的对象，会被放进老生区。

##### 主垃圾回收器

除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。

采用**Mark-Sweep**（标记-清除）和**Mark-Compact**（标记-整理）

1. **Mark-Sweep**

   遍历堆中对象是否被引用，清除未引用的垃圾数据

<img src="https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png" alt="img" style="zoom: 40%;" />

​		缺点：会产生内存碎片。

2. **Mark-Compact**

   标记存活对象后，移动存活对象到一端，然后再清除端边界外面的内存。

   <img src="https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png" alt="img" style="zoom:40%;" />

   优点：解决了Mark-Sweep产生内存碎片的问题。

   缺点：效率不如Mark-Sweep快。当空间不足以接收对象时，才会采用Mark-compact。

##### 垃圾回收机制的优化

scavenge，Mark-Sweep，Mark-compact都会导致**stop-the-world**（全停顿），会导致主线程占用时间过长，产生“卡顿”现象。因此V8引入**增量标记（Incremental Marking）**将回收任务分成很多小任务，在主线程穿插执行，避免长时间卡顿现象。

面试快捷【https://mp.weixin.qq.com/s/vbG24Ogc5qMpTz-_Hz61KQ】



